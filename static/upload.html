<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Upload & Ingest Files</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#9ca3af; --accent:#3b82f6; --ok:#10b981; --err:#ef4444; }
    body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; background:var(--bg); color:var(--text); }
    .wrap { max-width: 860px; margin: 40px auto; padding: 0 16px; }
    h1 { font-size: 20px; font-weight: 700; margin: 0 0 12px; }
    p { color: var(--muted); margin: 0 0 18px; }
    .card { background: var(--panel); border: 1px solid #1f2937; border-radius: 12px; padding: 18px; }
    .row { display:flex; gap: 12px; align-items:center; flex-wrap:wrap; margin-bottom: 12px; }
    .file-input { display:none; }
    .btn { background: var(--accent); color:white; border:0; padding: 10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .drop { border:2px dashed #334155; border-radius:10px; padding: 24px; text-align:center; color:var(--muted); transition: .15s border-color; }
    .drop.dragover { border-color: var(--accent); color: var(--text); }
    .list { margin-top: 14px; display:grid; gap:10px; }
    .item { background:#0b1220; border:1px solid #1f2937; border-radius:10px; padding:12px; }
    .item-head { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 600px; }
    .badge { font-size:12px; color:#d1d5db; }
    .bar { height:8px; border-radius:999px; background:#0f172a; border:1px solid #1f2937; margin-top:8px; overflow:hidden; }
    .fill { height:100%; width:0%; background:var(--accent); transition: width .15s linear; }
    .status { margin-top:6px; font-size:12px; color:var(--muted); }
    .status.ok { color: var(--ok); }
    .status.err { color: var(--err); }
    .small { font-size:12px; color:var(--muted); }
    .resp { margin-top:16px; background:#0b1220; border:1px solid #1f2937; border-radius:10px; padding:12px; max-height:280px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#d1d5db;}
    a { color:#93c5fd; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Upload & Ingest Files</h1>
    <p>
      Upload PDFs, DOCX, XLSX (legacy DOC auto-converted if LibreOffice is available).
      Files are parsed and indexed <b>in the background</b>. This page will show status when ingestion is truly complete.
    </p>

    <div class="card">
      <div class="row">
        <button id="pickBtn" class="btn">Choose files</button>
        <button id="uploadBtn" class="btn" disabled>Upload & Ingest</button>
        <span class="small">You can also drag &amp; drop files below.</span>
      </div>

      <input id="fileInput" class="file-input" type="file" multiple />
      <div id="drop" class="drop">Drag &amp; drop files here…</div>
      <div id="list" class="list"></div>

      <div class="small" style="margin-top:8px">
        Endpoint: <code>/ingest/upload</code> • Status: <code>/ingest/status/:job_id</code>
      </div>

      <pre id="resp" class="resp" hidden></pre>
    </div>
  </div>

  <script>
    const ENDPOINT = "/ingest/upload";
    const STATUS_EP = (id) => `/ingest/status/${id}`;

    const fileInput = document.getElementById('fileInput');
    const pickBtn   = document.getElementById('pickBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const dropZone  = document.getElementById('drop');
    const listEl    = document.getElementById('list');
    const respEl    = document.getElementById('resp');

    let queue = []; // { file, el, bar, statusEl }

    function bytes(n){ return n < 1024 ? n+' B' : n<1048576 ? (n/1024).toFixed(1)+' KB' : (n/1048576).toFixed(1)+' MB'; }

    function addFiles(files) {
      for (const file of files) {
        const el = document.createElement('div');
        el.className = 'item';
        el.innerHTML = `
          <div class="item-head">
            <div class="name" title="${file.name}">${file.name}</div>
            <div class="badge">${bytes(file.size)}</div>
          </div>
          <div class="bar"><div class="fill"></div></div>
          <div class="status">Queued</div>
        `;
        listEl.appendChild(el);
        queue.push({ file, el, bar: el.querySelector('.fill'), statusEl: el.querySelector('.status') });
      }
      uploadBtn.disabled = queue.length === 0;
    }

    pickBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => addFiles(e.target.files));

    // drag & drop
    ['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover');
    }));
    ['dragleave','drop'].forEach(ev => dropZone.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover');
    }));
    dropZone.addEventListener('drop', e => addFiles(e.dataTransfer.files));

    // --- Poll server job status (up to 30 minutes) ---
    async function pollStatus(jobId, onUpdate) {
      const deadline = Date.now() + (30 * 60 * 1000);   // 30 min max per file
      let delay = 5000;                                  // 5s start
      while (Date.now() < deadline) {
        try {
          const r = await fetch(STATUS_EP(jobId), { cache: 'no-store' });
          if (r.ok) {
            const j = await r.json();
            if (onUpdate) onUpdate(j);

            if (j.status === 'done')   return { ok:true, body:j };
            if (j.status === 'error')  return { ok:false, body:j };
          } else {
            // if status endpoint fails transiently, keep polling
          }
        } catch (_) { /* ignore transient fetch error */ }

        // exponential backoff with cap
        await new Promise(res => setTimeout(res, delay));
        delay = Math.min(delay * 1.4, 15000);
      }
      return { ok:false, body:{ status:'timeout', note:'Timed out waiting for ingestion' } };
    }

    // --- Upload ONE file (returns {ok, job_id, body}) ---
    function uploadOne(item, timeoutMs = 10 * 60 * 1000) {
      return new Promise((resolve) => {
        const form = new FormData();
        form.append('files', item.file, item.file.name);

        const xhr = new XMLHttpRequest();
        xhr.open('POST', ENDPOINT, true);
        xhr.timeout = timeoutMs;

        item.statusEl.textContent = 'Uploading…';

        xhr.upload.onprogress = (e) => {
          if (!e.lengthComputable) return;
          const pct = Math.round((e.loaded / e.total) * 100);
          item.bar.style.width = pct + '%';
          item.statusEl.textContent = `Uploading… ${pct}%`;
        };

        xhr.onerror = () => resolve({ ok:false, error:'network' });
        xhr.ontimeout = () => resolve({ ok:false, error:'timeout' });

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            const ok = xhr.status >= 200 && xhr.status < 300;
            if (!ok) {
              let msg = `Error ${xhr.status}`;
              try { msg += ': ' + (JSON.parse(xhr.responseText).error || ''); } catch {}
              return resolve({ ok:false, error: msg });
            }
            // Parse {"job_id":"...","status":"queued"}
            let job_id = null;
            try { job_id = JSON.parse(xhr.responseText).job_id; } catch {}
            resolve({ ok:true, job_id, body: xhr.responseText });
          }
        };
        xhr.send(form);
      });
    }

    // --- Upload SEQUENTIALLY with status polling ---
    async function uploadSequential() {
      respEl.hidden = true;
      pickBtn.disabled = true;
      uploadBtn.disabled = true;

      const summary = { ok: 0, failed: 0, details: [] };

      for (const item of queue) {
        // 1) upload
        const sent = await uploadOne(item);
        if (!sent.ok || !sent.job_id) {
          item.statusEl.textContent = 'Failed to submit job';
          item.statusEl.classList.add('err');
          summary.details.push({ file:item.file.name, ...sent });
          summary.failed++;
          continue;
        }

        item.bar.style.width = '100%';
        item.statusEl.textContent = 'Queued (server is ingesting)…';

        // 2) poll status
        const res = await pollStatus(sent.job_id, (j) => {
          // update live state
          if (j.step)  item.statusEl.textContent = `${j.step.replace(/-/g,' ')}…`;
          if (j.status === 'processing') item.statusEl.textContent = 'Processing…';
        });

        if (res.ok) {
          item.statusEl.textContent = 'Ingested';
          item.statusEl.classList.add('ok');
          summary.ok++;
          summary.details.push({ file:item.file.name, ok:true, job_id:sent.job_id, result:res.body?.result || null });
        } else {
          const note = res.body?.note || 'Error';
          item.statusEl.textContent = note;
          item.statusEl.classList.add('err');
          summary.failed++;
          summary.details.push({ file:item.file.name, ok:false, job_id:sent.job_id, error:note, body:res.body });
        }
      }

      respEl.hidden = false;
      respEl.textContent = JSON.stringify(summary, null, 2);
      queue = [];
      pickBtn.disabled = false;
    }

    uploadBtn.addEventListener('click', uploadSequential);
  </script>
</body>
</html>
